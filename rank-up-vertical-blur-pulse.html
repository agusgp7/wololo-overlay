<script>
const API="https://wololo-backend.onrender.com/ranking";
const REFRESH_MS=12000;
const SHOW_MS=8000;                 // duraciÃ³n visible de cada evento
const GAP_MS=250;                   // pausa mÃ­nima entre eventos en cola
const AVATAR_BASE="./avatars/";
const TEST_MODE=new URLSearchParams(location.search).get("test")==="1";

let testShown = false;

/* ðŸ‡¨ðŸ‡¦ðŸ‡¦ðŸ‡· etc â†’ PNG (OBS-safe) */
function countryFlag(cc){
  if(!cc||cc.length!==2)return"";
  const A="A".charCodeAt(0);
  const up=cc.toUpperCase();
  const c1=0x1F1E6+(up.charCodeAt(0)-A);
  const c2=0x1F1E6+(up.charCodeAt(1)-A);
  return `https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/${c1.toString(16)}-${c2.toString(16)}.png`;
}

function slugify(n){
  return n.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]+/g,"-");
}

function toRankNum(v){
  const n = Number(String(v).replace("#","").trim());
  return Number.isFinite(n) ? n : NaN;
}

const card = document.getElementById("card");
let prev = new Map();
let loaded = false;

// âœ… cola de eventos
const queue = [];
let playing = false;

function avatar(name){
  const box=document.getElementById("avatarBox");
  const img=new Image();
  img.onload=()=>{box.innerHTML="";box.appendChild(img);}
  img.onerror=()=>{box.innerHTML=`<div class="initials">${name.slice(0,2).toUpperCase()}</div>`;}
  img.src=`${AVATAR_BASE}${slugify(name)}.png`;
}

function update(e){
  document.getElementById("playerName").textContent=e.name;
  document.getElementById("deltaText").textContent=`+${e.delta}`;
  document.getElementById("rankTextTop").textContent=`#${e.old} â†’ #${e.rank}`;
  document.getElementById("eloText").textContent=`ELO ${e.elo}`;

  const f=document.getElementById("flagTop");
  const url=countryFlag((e.country||"").toUpperCase());
  if(url){
    f.onload=()=>f.style.display="block";
    f.onerror=()=>f.style.display="none";
    f.src=url;
  }else{
    f.style.display="none";
    f.removeAttribute("src");
  }

  avatar(e.name);
}

function showNow(){
  card.classList.add("show");
}
function hideNow(){
  card.classList.remove("show");
}

/**
 * âœ… muestra un evento y cuando termina, pasa al siguiente en cola
 */
function playNext(){
  if (playing) return;
  const evt = queue.shift();
  if (!evt) return;

  playing = true;
  update(evt);
  showNow();

  setTimeout(() => {
    hideNow();
    setTimeout(() => {
      playing = false;
      // si hay mÃ¡s, sigue
      if (queue.length) playNext();
    }, GAP_MS);
  }, SHOW_MS);
}

/**
 * âœ… agrega a cola evitando duplicados inmediatos
 * (por seguridad, si un refresh trae dos veces el mismo jugador con mismo delta)
 */
function enqueue(evt){
  const key = `${evt.name}|${evt.old}->${evt.rank}|+${evt.delta}`;
  // evita duplicado si ya estÃ¡ al final de la cola
  const last = queue.length ? queue[queue.length - 1] : null;
  const lastKey = last ? `${last.name}|${last.old}->${last.rank}|+${last.delta}` : "";
  if (key === lastKey) return;
  queue.push(evt);
}

/**
 * âœ… tick: detecta TODOS los rank-ups del refresh y los mete en cola
 */
async function tick(){
  if(TEST_MODE){
    if(testShown) return;
    testShown = true;

    // demo: 2 eventos en cola
    enqueue({name:"Hera",rank:1,old:3,delta:2,elo:1589,country:"ca"});
    enqueue({name:"Liereyy",rank:9,old:10,delta:1,elo:1536,country:"at"});
    playNext();
    return;
  }

  let d;
  try{
    const r=await fetch(API,{cache:"no-store"});
    if(!r.ok) return;
    d=await r.json();
    if(!Array.isArray(d)) return;
  }catch{
    return;
  }

  // Inicializar mapa previo
  if(!loaded){
    d.forEach(x=>{
      const rn = toRankNum(x.rank);
      if(Number.isFinite(rn)) prev.set(x.name, rn);
    });
    loaded = true;
    return;
  }

  // Detectar cambios (rank-up) del refresh actual
  const events = [];
  for(const x of d){
    const newRank = toRankNum(x.rank);
    const oldRank = prev.get(x.name);
    if(!Number.isFinite(newRank) || !Number.isFinite(oldRank)) continue;

    const delta = oldRank - newRank;

    // âœ… SOLO rank-up
    if(delta > 0){
      events.push({
        name: x.name,
        rank: newRank,
        old: oldRank,
        delta,
        elo: x.elo,
        country: x.country
      });
    }
  }

  // Orden sugerido: primero el que mÃ¡s subiÃ³, luego por mejor rank final
  events.sort((a,b) => (b.delta - a.delta) || (a.rank - b.rank));

  // Meter a cola todos los eventos detectados
  for (const evt of events) enqueue(evt);

  // Disparar reproducciÃ³n si no estaba mostrando nada
  if(queue.length) playNext();

  // Actualizar prev map al final
  prev.clear();
  d.forEach(x=>{
    const rn = toRankNum(x.rank);
    if(Number.isFinite(rn)) prev.set(x.name, rn);
  });
}

tick();
setInterval(tick, REFRESH_MS);
</script>
